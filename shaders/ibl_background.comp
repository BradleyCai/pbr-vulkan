#version 460

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba16f, set = 0, binding = 0) uniform image2D image;
layout(set = 0, binding = 1) uniform sampler2D iblTexture;

//push constants block
layout(push_constant) uniform constants {
	vec4 data1;
	vec4 data2;
	vec4 data3;
	vec4 data4;
} PushConstants;

const float TAU = 6.28318530718;

// input view vector assumed to be right handed, y up, and z forward
vec2 dirToRectilinear(vec3 dir) {
	float x = atan(dir.x, dir.z) / TAU + 0.5;
	float y = dir.y * 0.5 + 0.5;
	return vec2(x, y);
}

// right handed, y up, z forward
mat3 ypToRotMat(float yaw, float pitch) {
	float cosYaw = cos(yaw);
	float sinYaw = sin(yaw);
	float cosPitch = cos(pitch);
	float sinPitch = sin(pitch);
	
	vec3 xBasis = vec3(cosYaw, 0.0, sinYaw);
	vec3 yBasis = vec3(-sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);
	vec3 zBasis = vec3(-sinYaw * cosPitch, sinPitch, cosYaw * cosPitch);

	return mat3(xBasis, yBasis, zBasis);
}

mat3 yawToRotMat(float yaw) {
	float cosYaw = cos(yaw);
	float sinYaw = sin(yaw);
	
	vec3 xBasis = vec3(cosYaw, 0.0, sinYaw);
	vec3 yBasis = vec3(0.0, 1.0, 0.0);
	vec3 zBasis = vec3(-sinYaw, 0.0, cosYaw);
	
	return mat3(xBasis, yBasis, zBasis);
}

mat3 pitchToRotMat(float pitch) {
	float cosPitch = cos(pitch);
	float sinPitch = sin(pitch);
	
	vec3 xBasis = vec3(1.0, 0.0, 0.0);
	vec3 yBasis = vec3(0.0, cosPitch, -sinPitch);
	vec3 zBasis = vec3(0.0, sinPitch, cosPitch);
	
	return mat3(xBasis, yBasis, zBasis);
}

void main() {
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(image);

	if(texelCoord.x < size.x && texelCoord.y < size.y) {
		vec2 uv = vec2(texelCoord) / vec2(size);

		float cameraYaw = PushConstants.data4.x;
		float cameraPitch = PushConstants.data4.y;
		float yFov = PushConstants.data4.w;

		float aspect_ratio = float(size.x) / float(size.y);
		float yFovRadians = (yFov / 360.0) * TAU;
		float xFovRadians = yFovRadians;
		float xTan = tan(xFovRadians / 2.0) * aspect_ratio;
		float yTan = tan(yFovRadians / 2.0);

		vec3 fragOffsetDir = normalize(vec3(xTan * (uv.x * 2.0 - 1.0), yTan * (uv.y * 2.0 - 1.0), -1.0));

		vec3 fragView = yawToRotMat(cameraYaw) * pitchToRotMat(cameraPitch) * fragOffsetDir;

		imageStore(image, texelCoord, texture(iblTexture, dirToRectilinear(fragView)) * 0.6 + 0.1);
	}
}
