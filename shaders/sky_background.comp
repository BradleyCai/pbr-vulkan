#version 460

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba16f, set = 0, binding = 0) uniform image2D image;
layout(set = 0, binding = 1) uniform sampler2D iblTexture;

//push constants block
layout(push_constant) uniform constants {
	vec4 data1;
	vec4 data2;
	vec4 data3;
	vec4 data4; // camera: yaw, pitch, unused, fov
} PushConstants;

const float TAU = 6.28318530718;

// input view right handed, y up, and z forward
// image coordinates start from top left
vec2 dirToRectilinear(vec3 dir) {
	float x = atan(dir.x, dir.z) / TAU + 0.5;
	float y = 1.0 - (dir.y * 0.5 + 0.5);
	return vec2(x, y);
}

mat3 yawToRotMat(float yaw) {
	float cosYaw = cos(yaw);
	float sinYaw = sin(yaw);
	
	vec3 xBasis = vec3(cosYaw, 0.0, sinYaw);
	vec3 yBasis = vec3(0.0, 1.0, 0.0);
	vec3 zBasis = vec3(-sinYaw, 0.0, cosYaw);
	
	return mat3(xBasis, yBasis, zBasis);
}

mat3 pitchToRotMat(float pitch) {
	float cosPitch = cos(pitch);
	float sinPitch = sin(pitch);
	
	vec3 xBasis = vec3(1.0, 0.0, 0.0);
	vec3 yBasis = vec3(0.0, cosPitch, -sinPitch);
	vec3 zBasis = vec3(0.0, sinPitch, cosPitch);
	
	return mat3(xBasis, yBasis, zBasis);
}

vec3 tonemapFilmic(vec3 color, float white) {
	// exposure bias: input scale (color *= bias, white *= bias) to make the brightness consistent with other tonemappers
	// also useful to scale the input to the range that the tonemapper is designed for (some require very high input values)
	// has no effect on the curve's general shape or visual properties
	const float exposure_bias = 3.0f;
	const float A = 0.22f * exposure_bias * exposure_bias; // bias baked into constants for performance
	const float B = 0.30f * exposure_bias;
	const float C = 0.10f;
	const float D = 0.20f;
	const float E = 0.01f;
	const float F = 0.30f;

	vec3 color_tonemapped = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
	float white_tonemapped = ((white * (A * white + C * B) + D * E) / (white * (A * white + B) + D * F)) - E / F;

	return color_tonemapped / white_tonemapped;
}

void main() {
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(image);

	if(texelCoord.x < size.x && texelCoord.y < size.y) {
		vec2 uv = vec2(texelCoord) / vec2(size);

		float cameraYaw = PushConstants.data4.x;
		float cameraPitch = PushConstants.data4.y;
		float yFov = PushConstants.data4.w;

		float aspect_ratio = float(size.x) / float(size.y);
		float yFovRadians = (yFov / 360.0) * TAU;
		float xFovRadians = yFovRadians;
		float xTan = tan(xFovRadians / 2.0) * aspect_ratio;
		float yTan = tan(yFovRadians / 2.0);

		vec3 fragOffsetDir = normalize(vec3(xTan * (uv.x * 2.0 - 1.0), -yTan * (uv.y * 2.0 - 1.0), 1.0));

		vec3 fragView = yawToRotMat(cameraYaw) * pitchToRotMat(cameraPitch) * fragOffsetDir;

		vec4 color = texture(iblTexture, dirToRectilinear(fragView));
		imageStore(image, texelCoord, vec4(tonemapFilmic(color.rgb, 2.0), color.a));
	}
}
